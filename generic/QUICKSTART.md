# Quick Start

Guide showing how to write programs using the rx generics library.

## Prepare the Working Directory
Let's create a new folder for our simple program and start editing the file `main.go`.

```bash
$ mkdir -p ~/go/hellorx
$ cd ~/go/hellorx
$ go mod init hellorx
go: creating new go.mod: module hellorx
$ subl main.go
```
> We use *Sublime Text* for code editing, hence the use of the `subl` command.

## Write the Program
Now that you have your `main.go` file open (in the editor of your choice), enter the following code:

```go
package main

import _ "github.com/reactivego/rx/generic"

func main() {
	FromString("You!", "Gophers!", "World!").
		MapString(func(x string) string {
			return "Hello, " + x
		}).
		Println()
}
```
Running the program from the command-line will fail:
```bash
$ go run *.go
# command-line-arguments
./main.go:6:2: undefined: FromString
```

## Generate Code
Go to the command-line again and run the [jig](https://github.com/reactivego/jig) tool.
Use the verbose flag `-v` to see what [jig](https://github.com/reactivego/jig) is doing:
```bash
$ jig -v
found 149 templates in package "rx" (github.com/reactivego/rx/generic)
generating "FromString"
  Scheduler
  Subscriber
  StringObserver
  ObservableString
  FromString
generating "ObservableString MapString"
  ObservableString MapString
generating "ObservableString Println"
  ObservableString Println
writing file "rx.go"
```
> The file **rx.go** was generated

## Run the Program
Now we can try to run the code and see what it does.

```bash
$ go run main.go rx.go
Hello, You!
Hello, Gophers!
Hello, World!
```
> Success! 

## Inspect the Code
Let's take a look at the code generated into the file *rx.go*.
The idea behind [jig](https://github.com/reactivego/jig) (Just In-time Generics) has been to generate the minimal amount of code needed to make a program run.
Turns out the generated file *rx.go* contains only around 70 lines of code:

```go
// Code generated by jig; DO NOT EDIT.

//go:generate jig

package main

import (
  "fmt"

  "github.com/reactivego/scheduler"
  "github.com/reactivego/rx/subscriber"
)

type Scheduler = scheduler.Scheduler
type Subscriber = subscriber.Subscriber

type StringObserver func(next string, err error, done bool)
type ObservableString func(StringObserver, Scheduler, Subscriber)

func FromString(slice ...string) ObservableString {
  var zeroString string
  observable := func(observe StringObserver, scheduler Scheduler, subscriber Subscriber) {
    i := 0
    runner := scheduler.ScheduleRecursive(func(self func()) {
      if subscriber.Subscribed() {
        if i < len(slice) {
          observe(slice[i], nil, false)
          if subscriber.Subscribed() {
            i++
            self()
          }
        } else {
          observe(zeroString, nil, true)
        }
      }
    })
    subscriber.OnUnsubscribe(runner.Cancel)
  }
  return observable
}

func (o ObservableString) MapString(project func(string) string) ObservableString {
  observable := func(observe StringObserver, subscribeOn Scheduler, subscriber Subscriber) {
    observer := func(next string, err error, done bool) {
      var mapped string
      if !done {
        mapped = project(next)
      }
      observe(mapped, err, done)
    }
    o(observer, subscribeOn, subscriber)
  }
  return observable
}

func (o ObservableString) Println(a ...interface{}) (err error) {
  subscriber := NewSubscriber()
  scheduler := NewScheduler()
  observer := func(next string, e error, done bool) {
    if !done {
      fmt.Println(append(a, next)...)
    } else {
      err = e
      subscriber.Unsubscribe()
    }
  }
  subscriber.OnWait(scheduler.Wait)
  o(observer, scheduler, subscriber)
  subscriber.Wait()
  return
}
```
If you add additional code to the program that uses different generics of the `rx` library, then you should run `jig` again to generate specializations of those generics.
